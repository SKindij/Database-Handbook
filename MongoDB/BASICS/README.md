# ðŸ“š MongoDB Basics

## <a name="basics"></a>ðŸ“– Data Model 

### BSON vs JSON

&ensp; BSON is a binary-encoded serialization of JSON-like documents. It is designed to be efficient in storage, traversability, and encoding/decoding. 
Some of its key features include:
+ Binary Encoding: 
  * BSON encodes data in a binary format, which offers better performance and allows the storage of data types not supported by JSON.
+ Support for Additional Data Types: 
  * BSON supports more data types compared to JSON, such as Date, Binary, ObjectId, and Decimal128. This makes it possible to represent diverse data more accurately in MongoDB documents.
+ Efficient Traversability: 
  * In BSON, the size of each element is encoded, which makes it easy to skip over elements, thus making the traversal faster.

Some features of JSON include:
+ Human-readable: 
  * JSON is textual with a simple structure, making it easy for humans to read and write.
+ Interoperable: 
  * JSON can be easily parsed and generated by many different programming languages, making it a popular choice for data interchange between applications.
+ Limited Data Types: 
  * This means that some data, like dates or binary data, must be represented as strings or custom objects in JSON.

### Data Types
&ensp; In MongoDB, data is stored in **BSON** format, which supports various data types. 
Understanding these data types is essential as they play a crucial role in schema design and query performance.\
&ensp; The following is a brief summary of the different data types supported in MongoDB.

&ensp; We can consider this subtopic on the basis of the "The Witcher" universe.
+ **String**
  * it is used to store text; 
  * _for example: character's name;_
+ **Integer**
  * it is used to store whole numbers;
  * MongoDB supports 32-bit and 64-bit integers;
  * _for example: character's age;_
+ **Double**
  * it is used to store floating-point numbers;
  * _for example: character's weight & height;_
  * ```javascript
      {
        name: "Geralt of Rivia",
        age: 100,
        weight: 90.5,
        height: 190.0,
        occupation: "Witcher",
        weapon: "Silver sword",
        catchphrase: "Evil is evil. Lesser, greater, middling, it's all the same.",
      }
    ```  
+ **Boolean**
  * it is used to store true or false values;
  * _for example: whether a character is a monster or not;_
  * ```javascript  
      {
        name: "Ciri",
        age: 22,
        monster: false,
        occupation: "Princess",
        location: "Kaer Morhen"
      }
    ```
+ **Date**
  * it is used to store dates and times;
  * Dates are stored as UTC times;
  * _for example: character's date of birth;_
+ **Array**
  * it is used to store an ordered list of values;
  * you can store multiple data types in an array; 
  * _for example: list of magic spells;_
  * ```javascript  
      {
        name: "Yennefer of Vengerberg",
        dateOfBirth: new Date("1173-02-09"),
        spells: ["Aard", "Quen", "Axii"],
        occupation: "Sorceress",
      }  
    ```
+ **ObjectID**
  * it is used to store unique identifiers for documents in collection;
  * MongoDB generates ObjectIDs automatically when you insert a new document;
  * _for example: unique identifier for each character;_
  * _for Geralt's document in database could be "60a7a0c0a55b150011285d77";_
  * ```javascript
      const { ObjectID } = require("mongodb");
  
      const character = {
        _id: new ObjectID(),
        name: "Triss Merigold",
        occupation: "Sorceress",
      }
  
      db.collection("characters").insertOne(character);
    ```
+ **Binary data**
  * it is used to store binary data, such as images or audio files;
  * _for example: image of monster that Geralt has hunted;_
  * ```javascript
      const fs = require("fs");
      const monsterImage = fs.readFileSync("path/to/image.jpg");

      const monster = {
        name: "Striga",
        image: monsterImage,
        description: "A cursed princess turned into a monster",
      }

      db.collection("monsters").insertOne(monster);
    ```
+ **Regular expression**
  * it is used to store regular expressions, which are used to match patterns in strings;
  * _for example: to search for character names;_
  * ```javascript
        const query = {
        name: /ger/i,
      }

      db.collection("characters").find(query);
    ```
  * _example of query:_ ``db.collection.find({ name: { $regex: 'J.*' } });``
+ **Null**
  * it is used to store a null value;
  * _for example: if character does not have specific attribute;_
  * ```javascript
     {
       name: "Jaskier",
       occupation: "Bard",
       lastName: null,
     }
    ```

### Embedded Documents Arrays
&ensp; In MongoDB, one of the powerful features is the ability to store complex data structures like Embedded Documents Arrays. These are essentially arrays of sub-documents (also known as nested documents) that can be stored within a single document. This allows us to model complex data relationships in a highly efficient way while maintaining good performance.
```javascript
{
  name: "Geralt of Rivia",
  occupation: "Witcher",
  quests: [
    {
      name: "The Last Wish",
      location: "Skellige",
      completed: true
    },
    {
      name: "The Tower Outta Nowheres",
      location: "Velen",
      completed: false
    },
    {
      name: "The Witcher's Forge",
      location: "Kaer Morhen",
      completed: false
    }
  ]
}
```

> _Keep in mind that MongoDB has a document size limitation of 16MB, so if you expect the embedded data to grow over time, you should consider alternative approaches, such as using separate collections and referencing them instead._


## <a name="colometh"></a>ðŸ“– Collections and Methods
&ensp; In MongoDB, a collection is a group of related documents that are stored in a MongoDB database. Collections are analogous to tables in relational databases. Each collection in MongoDB has a unique name and can contain any number of documents.

### Creating database and collections
1. to create certain database:
```perl
  use witcherWorld_db
```
2. to create collection in that database:\
&ensp; Here are some of the most common options that developers specify when creating collections:
+ capped: 
  * it creates a capped collection with a fixed size; 
  * once collection reaches its maximum size, older documents will be automatically removed to make room for new ones;
+ size: 
  * it sets the maximum size of a capped collection in bytes;
+ max: 
  * it sets the maximum number of documents allowed in a collection;
+ validator: 
  * it sets validation rule for documents in collection;
  * documents that do not meet validation rule will not be inserted;
+ validationLevel: 
  * it sets level of validation for documents in collection;
  * possible values are "off", "strict", and "moderate";
+ validationAction: 
  * it specifies what action to take when document fails validation;
  * possible values are "error", "warn", and "ignore";
+ autoIndex: 
  * it enables or disables automatic indexing for collection;
  * when enabled, MongoDB automatically creates indexes for collection based on its schema;
+ storageEngine: 
  * it specifies storage engine to use for collection;
  * default storage engine is WiredTiger; 
  * other storage engines such as MMAPv1 and In-Memory are also available.
```perl
  db.createCollection("monsters", { capped: true, size: 800, max: 1000 }) 

  db.createCollection("characters", { capped: true, size: 1000, max: 1000,
    validator: {
      $or: [
        { name: { $type: "string" } },
        { alias: { $type: "string" } }
      ]
    },
    validationLevel: "strict",
    validationAction: "error",
    storageEngine: {
      wiredTiger: { configString: "block_compressor=zlib" }
    }
  })
```
3. to insert single document into "monsters" collection:
```perl
  db.monsters.insertOne({ name: "Griffin", description: "Powerful creature with head and wings of an eagle and body of a lion" })

  db.characters.insertOne({ name: "Ciri", age: 22, monster: false, occupation: "Princess", location: "Kaer Morhen" });
```
4. to insert multiple documents into "monsters" collection
```perl
  db.monsters.insertMany([
    { name: "Drowner", description: "Water-dwelling creature that preys on humans and animals" },
    { name: "Nekker", description: "Small, goblin-like creature that lives in groups and can be dangerous in large numbers" },
    { name: "Leshen", description: "Forest-dwelling creature that can control plants and animals" }
  ])
```

### Counting Documents
&ensp; When working with MongoDB, you might often need to know the number of documents present in a collection. MongoDB provides a few methods to efficiently count documents in a collection. 
+ **countDocuments()**
  * it is used to count number of documents in collection based on specified filter;
  * it provides an accurate count that may involve reading all documents in collection;
  * syntax: ``collection.countDocuments(filter, options);``
+ **estimatedDocumentCount()**
  * it provides approximate count of documents in collection, without applying any filters;
  * it uses collectionâ€™s metadata to determine count and is generally faster;
  * syntax: ``collection.estimatedDocumentCount(options);``

### bulkWrite()
&ensp; Bulk write operations allow you to perform multiple create, update, and delete operations in a single command, which can significantly improve the performance of your application. 
+ Ordered Bulk Write: 
  * MongoDB executes the write operations in the order you provide;
  * if a write operation fails, MongoDB returns an error and does not proceed with the remaining operations;
  * ```javascript
      const witcherCollection = db.collection('witcherCharacters').initializeOrderedBulkOp();
        // insert new character
        witcherCollection.insert({ _id: 1, name: 'Geralt of Rivia', profession: 'Witcher' });
        // update existing character
        witcherCollection.find({ name: 'Yennefer' }).updateOne({ $set: { profession: 'Sorceress' } });
        // remove character
        witcherCollection.find({ _id: 3 }).remove();
        // execute the bulk operation
        witcherCollection.execute((err, result) => {
            // handle errors or results
        });
     ```
+ Unordered Bulk Write: 
  * MongoDB can execute the write operations in any order;
  * if a write operation fails, MongoDB will continue to process the remaining write operations;
  * ```javascript
       const witcherCollection = db.collection('witcherCharacters').initializeUnorderedBulkOp();
     ```

### validate()
&ensp; This command is used to examine a MongoDB collection to verify and report on the correctness of its internal structures, such as indexes, namespace details, or documents. It can also return statistics about the storage and distribution of data within a collection.\
The basic syntax of the validate command is as follows: ``db.runCommand({validate: "<collection_name>", options...})``

> _Keep in mind that validate command should be used mainly for diagnostics and troubleshooting purposes, as it can impact system performance when validating large collections or when using full flag. Use it when you suspect that there might be corruption or discrepancies within the collectionâ€™s data or internal structures_



## <a name="concepts"></a>ðŸ“– Useful Concepts
&ensp; **MongoDB Query Language** (MQL) is the syntax used for querying MongoDB databases, performing **CRUD operations** (Create, Read, Update, and Delete), and managing database administration tasks. **MQL** is concise, powerful, and easy to use.\
&ensp; **Indexing** is crucial for optimizing database performance. MongoDB supports various types of indexes, including single-field, compound, and text indexes.\
&ensp; With the aggregation framework, you can perform complex data analysis tasks, such as filtering, grouping, and computing averages, efficiently and with ease.\
&ensp; MongoDB offers high availability by allowing **data replication** across multiple servers. The replication feature ensures that if one server becomes unavailable, the others can continue to function without data loss.\
&ensp; One of MongoDBâ€™s strengths is its ability to scale horizontally through **sharding**, the process of splitting and distributing data across multiple servers or clusters. This helps to distribute load, ensure better performance, and maintain availability as the size of the dataset grows.\
&ensp; **MongoDB Atlas** is fully managed, global cloud database service. It offers features such as automatic backup and scaling, as well as advanced security for your MongoDB data. Atlas makes it easy to deploy, manage, and optimize your MongoDB databases in the cloud.

### Read / Write Concerns

&ensp; A read concern determines the consistency level of the data returned by a query. It specifies the version of data that a query should return.\
&ensp; MongoDB supports different **read concern levels**:
+ local (default): 
  * _returns the most recent data available on the primary node at the time of query execution;_
  * _it does not guarantee consistency across replica sets;_
+ available: 
  * _query returns the most recent data available on the queried node;_
  * _this level is only applicable to sharded clusters;_
+ majority: 
  * _query returns data that has been acknowledged by a majority of replica set members;_
  * _it provides a higher level of consistency but may have higher latency;_
+ linearizable: 
  * _ensures reading the most recent data that has been acknowledged by a majority of replica sets;_
  * _this level guarantees highest consistency but can be the slowest among all levels;_
+ snapshot: 
  * _returns the data from a specific snapshot timestamp;_
  * _this level is useful for read transactions with snapshot isolation._

&ensp; A write concern indicates the level of acknowledgment MongoDB should provide when writing data to the database. It ensures that the data has been successfully written and replicated before acknowledging the write operation.\
&ensp; The different **write concern levels** are:
+ w: 0: 
  * _write operation is unacknowledged, which means MongoDB does not send any acknowledgment;_
  * _this level provides the lowest latency but carries the risk of losing data;_
+ w: 1 (default): 
  * _write operation is acknowledged after being successfully written to the primary node;_
  * _it does not guarantee replication to other replica set members;_
+ w: majority: 
  * _write operation is acknowledged after being written and replicated to a majority of replica set members;_
  * _this level provides better data durability but may have increased latency;_
+ w: <number>: 
  * _write operation is acknowledged after being replicated to the specified number of replica set members;_
  * _this level provides a custom level of data durability._

Additional options can be used to fine-tune the write concern:
+ j: true/false: 
  * _specifies whether the write operation must be written to the journal before acknowledgment;_
  * _setting ``j: true`` ensures the data is committed to the journal and provides increased durability;_
+ wtimeout: <ms>: 
  * _specifies a time limit in milliseconds for write operations to be acknowledged;_
  * _if the acknowledgment is not received within the specified time, the operation returns a timeout error. However, this does not mean the write operation failed; it may still be successful at a later point in time._
 
### Cursors
&ensp; It is an object that enables you to iterate over and retrieve documents from a query result.\
_When you execute a query to fetch documents from a database, MongoDB returns a pointer to the result set, known as a cursor. The cursor automatically takes care of batch processing of the result documents, providing an efficient way to handle large amounts of data._
> ```javascript
>  const cursor = db.collection('myCollection').find();
>   
>  cursor.forEach((doc) => { console.log(doc); }); 
> ``` 
 
&ensp; Cursors provide several methods that allow you to manipulate the result set and control the query execution. 
* ``count()``: returns total number of documents in result set;
* ``limit(n)``: limits number of documents retrieved to n;
* ``skip(n)``: skips first n documents in result set;
* ``sort(field, order)``: sorts documents (1 for ascending, -1 for descending);
* ``project(field)``: specifies fields to include or exclude from result documents. 
 
> ```javascript 
>  const witcherCursor = db
>    .collection('witcherCharacters')
>    .find({ profession: 'Witcher' }) // to search for all characters who are Witchers
>    .sort('name', 1) // to sort results by name in ascending order
>    .limit(12) // to limit the number of results to 12
>    .skip(9) // to skip the first 9 results
>    .project({ name: 1, age: 1, _id: 0 }); // to only return name and age fields, and exclude _id field
>  // to execute the query and return the results as an array
>  witcherCursor.toArray((err, result) => {
>    // handle error or result
>  });
> ``` 

&ensp; Cursors automatically close when all documents in the result set have been retrieved or after 10 minutes of inactivity. However, in some cases, you may want to manually close a cursor: ``cursor.close();``.
 
### Retryable Reads / Writes
&ensp; They are an essential feature in MongoDB that provides the ability to automatically retry certain read and write operations, ensuring data consistency and improving the fault tolerance of your applications. This feature is especially useful in case of transient network errors or replica set elections that may cause operations to fail temporarily.
* **retryable reads** allow MongoDB to automatically retry eligible read operations if they fail due to a transient error. This ensures that the application can continue to perform read operations seamlessly without throwing errors at users due to temporary issues.
  + Examples include: ``find(), aggregate(), distinct()``
* **retryable writes** allow MongoDB to automatically retry specific write operations that fail due to transient errors. This helps maintain data consistency and reduces the chances of data loss or duplicate writes.
  + Examples include: ``insertOne(), updateOne(), deleteOne(), findOneAndUpdate()``
 

## <a name="operators"></a>ðŸ“– Query Operators
&ensp; They provide powerful ways to search and manipulate documents in a MongoDB collection. 
 
### Comparison Operators allow you to compare the value of a field with specified values.
- ``$eq``: matches values that are equal to the specified value;
  * ``db.collection.find({ field: { $eq: value } });``
- ``$gt``: matches values that are greater than the specified value;
- ``$gte``: matches values that are greater than or equal to specified value;
- ``$lt``: matches values that are less than the specified value;
- ``$lte``: matches values that are less than or equal to specified value;
- ``$ne``: matches values that are not equal to the specified value;
- ``$in``: matches values that are in the specified array;
- ``$nin``: matches values that are not in the specified array.

### Logical Operators provide ways to combine multiple query conditions. 
- ``$and``: matches documents where all specified conditions are true;
  * ``db.collection.find({ $and: [{ expression1 }, { expression2 }, ... ] });``
- ``$or``: matches documents where at least one of specified conditions is true;
- ``$not``: matches documents where specified condition is not true;
  * ``db.collection.find({ field: { $not: { <operator-expression> } } });``
- ``$nor``: matches documents where none of specified conditions are true.

> ```javascript
>  const witcherCursor = db
>  // we're working with collection that stores info about characters from Witcher universe
>    .collection('witcherCharacters')
>    .find({ // to search for characters
>      age: { $gt: 50 }, // who are over 50 years old
>      $or: [ // who have profession of either "Sorceress" or "Witcher"
>        { profession: 'Sorceress' },
>        { profession: 'Witcher' },
>      ],
>      $nor: [ // who do not have status of either "Dead" or "Unknown"
>        { status: 'Dead' },
>        { status: 'Unknown' },
>      ],
>    })
>    .sort('age', -1); // to sort results by age in descending order
>  
>  witcherCursor.toArray((err, result) => {
>    // handle error or result
>  }); 
> ```  

### Element Operators are used to query documents based on the presence, type, or absence of a field and its value. 
- ``$exists``: matches documents that have the specified field;
  * ``db.collection.find({ field: { $exists: <boolean> } });``
- ``$type``: matches documents where specified field is of specified BSON type;
   * ``db.collection.find({ fieldName: {$type: dataType;} });``
- ``$regex``: searches for any documents that match the provided pattern;
   * ``db.collection.find({ fieldName: { $regex: 'your-pattern' } });``

### Evaluation Operators

 

### Array Operators

 

### Bitwise Operators







