# ðŸ“š MongoDB Basics

## <a name="basics"></a>ðŸ“– Data Model 

### BSON vs JSON

&ensp; BSON is a binary-encoded serialization of JSON-like documents. It is designed to be efficient in storage, traversability, and encoding/decoding. 
Some of its key features include:
+ Binary Encoding: 
  * BSON encodes data in a binary format, which offers better performance and allows the storage of data types not supported by JSON.
+ Support for Additional Data Types: 
  * BSON supports more data types compared to JSON, such as Date, Binary, ObjectId, and Decimal128. This makes it possible to represent diverse data more accurately in MongoDB documents.
+ Efficient Traversability: 
  * In BSON, the size of each element is encoded, which makes it easy to skip over elements, thus making the traversal faster.

Some features of JSON include:
+ Human-readable: 
  * JSON is textual with a simple structure, making it easy for humans to read and write.
+ Interoperable: 
  * JSON can be easily parsed and generated by many different programming languages, making it a popular choice for data interchange between applications.
+ Limited Data Types: 
  * This means that some data, like dates or binary data, must be represented as strings or custom objects in JSON.

### Data Types
&ensp; In MongoDB, data is stored in **BSON** format, which supports various data types. 
Understanding these data types is essential as they play a crucial role in schema design and query performance.\
&ensp; The following is a brief summary of the different data types supported in MongoDB.

&ensp; We can consider this subtopic on the basis of the "The Witcher" universe.
+ **String**
  * it is used to store text; 
  * _for example: character's name;_
+ **Integer**
  * it is used to store whole numbers;
  * MongoDB supports 32-bit and 64-bit integers;
  * _for example: character's age;_
+ **Double**
  * it is used to store floating-point numbers;
  * _for example: character's weight & height;_
  * ```javascript
      {
        name: "Geralt of Rivia",
        age: 100,
        weight: 90.5,
        height: 190.0,
        occupation: "Witcher",
        weapon: "Silver sword",
        catchphrase: "Evil is evil. Lesser, greater, middling, it's all the same.",
      }
    ```  
+ **Boolean**
  * it is used to store true or false values;
  * _for example: whether a character is a monster or not;_
  * ```javascript  
      {
        name: "Ciri",
        age: 22,
        monster: false,
        occupation: "Princess",
        location: "Kaer Morhen",
      }
    ```
+ **Date**
  * it is used to store dates and times;
  * Dates are stored as UTC times;
  * _for example: character's date of birth;_
+ **Array**
  * it is used to store an ordered list of values;
  * you can store multiple data types in an array; 
  * _for example: list of magic spells;_
  * ```javascript  
      {
        name: "Yennefer of Vengerberg",
        dateOfBirth: new Date("1173-02-09"),
        spells: ["Aard", "Quen", "Axii"],
        occupation: "Sorceress",
      }  
    ```
+ **ObjectID**
  * it is used to store unique identifiers for documents in collection;
  * MongoDB generates ObjectIDs automatically when you insert a new document;
  * _for example: unique identifier for each character;_
  * _for Geralt's document in database could be "60a7a0c0a55b150011285d77";_
  * ```javascript
      const { ObjectID } = require("mongodb");
  
      const character = {
        _id: new ObjectID(),
        name: "Triss Merigold",
        occupation: "Sorceress",
      }
  
      db.collection("characters").insertOne(character);
    ```
+ **Binary data**
  * it is used to store binary data, such as images or audio files;
  * _for example: image of monster that Geralt has hunted;_
  * ```javascript
      const fs = require("fs");
      const monsterImage = fs.readFileSync("path/to/image.jpg");

      const monster = {
        name: "Striga",
        image: monsterImage,
        description: "A cursed princess turned into a monster",
      }

      db.collection("monsters").insertOne(monster);
    ```
+ **Regular expression**
  * it is used to store regular expressions, which are used to match patterns in strings;
  * _for example: to search for character names;_
  * ```javascript
        const query = {
        name: /ger/i,
      }

      db.collection("characters").find(query);
    ```
  * _example of query:_ ``db.collection.find({ name: { $regex: 'J.*' } });``
+ **Null**
  * it is used to store a null value;
  * _for example: if character does not have specific attribute;_
  * ```javascript
     {
       name: "Jaskier",
       occupation: "Bard",
       lastName: null,
     }
    ```

### Embedded Documents Arrays
&ensp; In MongoDB, one of the powerful features is the ability to store complex data structures like Embedded Documents Arrays. These are essentially arrays of sub-documents (also known as nested documents) that can be stored within a single document. This allows us to model complex data relationships in a highly efficient way while maintaining good performance.
```javascript
{
  name: "Geralt of Rivia",
  occupation: "Witcher",
  quests: [
    {
      name: "The Last Wish",
      location: "Skellige",
      completed: true
    },
    {
      name: "The Tower Outta Nowheres",
      location: "Velen",
      completed: false
    },
    {
      name: "The Witcher's Forge",
      location: "Kaer Morhen",
      completed: false
    }
  ]
}
```

> _Keep in mind that MongoDB has a document size limitation of 16MB, so if you expect the embedded data to grow over time, you should consider alternative approaches, such as using separate collections and referencing them instead._


## <a name="colometh"></a>ðŸ“– Collections and Methods
&ensp; In MongoDB, a collection is a group of related documents that are stored in a MongoDB database. Collections are analogous to tables in relational databases. Each collection in MongoDB has a unique name and can contain any number of documents.

### Creating database and collections
1. to create certain database:
```perl
  use witcherWorld_db
```
2. to create collection in that database:\
_you can specify maximum number of documents that collection can hold_
```perl
  db.createCollection("monstersCollection", { capped: true, size: 800, max: 1000 })
```
3. to insert single document into "monsters" collection:
```perl
  db.monsters.insertOne({ name: "Griffin", description: "Powerful creature with head and wings of an eagle and body of a lion" })
```
4. to insert multiple documents into "monsters" collection
```perl
  db.monsters.insertMany([
    { name: "Drowner", description: "Water-dwelling creature that preys on humans and animals" },
    { name: "Nekker", description: "Small, goblin-like creature that lives in groups and can be dangerous in large numbers" },
    { name: "Leshen", description: "Forest-dwelling creature that can control plants and animals" }
  ])
```

&ensp; Here are some of the most common options that developers specify when creating collections:
+ capped: 
  * it creates a capped collection with a fixed size; 
  * once collection reaches its maximum size, older documents will be automatically removed to make room for new ones;
+ size: 
  * it sets the maximum size of a capped collection in bytes;
+ max: 
  * it sets the maximum number of documents allowed in a collection;
+ validator: 
  * it sets validation rule for documents in collection;
  * documents that do not meet validation rule will not be inserted;
+ validationLevel: 
  * it sets level of validation for documents in collection;
  * possible values are "off", "strict", and "moderate";
+ validationAction: 
  * it specifies what action to take when document fails validation;
  * possible values are "error", "warn", and "ignore";
+ autoIndex: 
  * it enables or disables automatic indexing for collection;
  * when enabled, MongoDB automatically creates indexes for collection based on its schema;
+ storageEngine: 
  * it specifies storage engine to use for collection;
  * default storage engine is WiredTiger; 
  * other storage engines such as MMAPv1 and In-Memory are also available.

```perl
  db.createCollection("characters", {
    capped: true,
    size: 10000,
    max: 500,
    validator: {
      $or: [
        { name: { $type: "string" } },
        { alias: { $type: "string" } }
      ]
    },
    validationLevel: "strict",
    validationAction: "error",
    autoIndex: false,
    storageEngine: {
      wiredTiger: { configString: "block_compressor=zlib" }
    }
  })
```

### Counting Documents
&ensp; When working with MongoDB, you might often need to know the number of documents present in a collection. MongoDB provides a few methods to efficiently count documents in a collection. 
+ **countDocuments()**
  * it is used to count number of documents in collection based on specified filter;
  * it provides an accurate count that may involve reading all documents in collection;





### validate()



## <a name="concepts"></a>ðŸ“– Useful Concepts

### Read / Write Concerns


### Cursors


### Retryable Reads / Writes



## <a name="operators"></a>ðŸ“– Query Operators

### Comparison Operators


### Logical Operators


### Element Operators


### Evaluation Operators


### Array Operators


### Bitwise Operators







